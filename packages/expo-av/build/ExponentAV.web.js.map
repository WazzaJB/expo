{"version":3,"file":"ExponentAV.web.js","sourceRoot":"","sources":["../src/ExponentAV.web.ts"],"names":[],"mappings":"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","sourcesContent":["import { SyntheticPlatformEmitter } from '@unimodules/core';\n\nimport { AVPlaybackNativeSource, AVPlaybackStatus, AVPlaybackStatusToSet } from './AV';\n\nimport { RECORDING_OPTIONS_PRESET_HIGH_QUALITY } from './Audio/Recording';\n\nfunction getStatusFromMedia(media?: HTMLMediaElement): AVPlaybackStatus {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined,\n    };\n  }\n\n  const isPlaying = !!(\n    media.currentTime > 0 &&\n    !media.paused &&\n    !media.ended &&\n    media.readyState > 2\n  );\n\n  const status: AVPlaybackStatus = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100, //TODO: Bacon: Add interval between calls\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    // playableDurationMillis: media.buffered * 1000,\n    // seekMillisToleranceBefore?: number\n    // seekMillisToleranceAfter?: number\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false, //media.waiting,\n    rate: media.playbackRate,\n    // TODO: Bacon: This seems too complicated right now: https://webaudio.github.io/web-audio-api/#dom-biquadfilternode-frequency\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended,\n  };\n\n  return status;\n}\n\nfunction setStatusForMedia(\n  media: HTMLMediaElement,\n  status: AVPlaybackStatusToSet\n): AVPlaybackStatus {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n  // if (status.progressUpdateIntervalMillis !== undefined) {\n  //   media.progressUpdateIntervalMillis = status.progressUpdateIntervalMillis;\n  // }\n  // if (status.seekMillisToleranceBefore !== undefined) {\n  //   media.seekMillisToleranceBefore = status.seekMillisToleranceBefore;\n  // }\n  // if (status.seekMillisToleranceAfter !== undefined) {\n  //   media.seekMillisToleranceAfter = status.seekMillisToleranceAfter;\n  // }\n  // if (status.shouldCorrectPitch !== undefined) {\n  //   media.shouldCorrectPitch = status.shouldCorrectPitch;\n  // }\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      media.play();\n    } else {\n      media.pause();\n    }\n  }\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nlet mediaRecorder: null | any /*MediaRecorder*/ = null;\n\nexport default {\n  get name(): string {\n    return 'ExponentAV';\n  },\n  async getStatusForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async loadForVideo(\n    element: HTMLMediaElement,\n    nativeSource: AVPlaybackNativeSource,\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async unloadForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async setStatusForVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replayVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  /* Audio */\n  async setAudioMode() {},\n  async setAudioIsEnabled() {},\n  async getStatusForSound(element: HTMLMediaElement) {\n    return getStatusFromMedia(element);\n  },\n  async loadForSound(\n    nativeSource: string | { uri: string; [key: string]: any },\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<[HTMLMediaElement, AVPlaybackStatus]> {\n    const source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n    const media = new Audio(source);\n\n    media.ontimeupdate = () => {\n      SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n        key: media,\n        status: getStatusFromMedia(media),\n      });\n    };\n\n    media.onerror = () => {\n      SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n        key: media,\n        error: media.error!.message,\n      });\n    };\n\n    const status = setStatusForMedia(media, fullInitialStatus);\n\n    return [media, status];\n  },\n  async unloadForSound(element: HTMLMediaElement) {\n    element.pause();\n    element.removeAttribute('src');\n    element.load();\n    return getStatusFromMedia(element);\n  },\n  async setStatusForSound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replaySound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n\n  /* Recording */\n  //   async setUnloadedCallbackForAndroidRecording() {},\n  async getAudioRecordingStatus() {\n    return {\n      isRecording: mediaRecorder?.state === 'recording',\n      isDoneRecording: false,\n      durationMillis: 2000,\n    };\n  },\n  async prepareAudioRecorder(options) {\n    if (typeof navigator !== 'undefined' && !navigator.mediaDevices) {\n      throw new Error('No media devices available');\n    }\n\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n\n    mediaRecorder = new (window as any).MediaRecorder(\n      stream,\n      options?.web || RECORDING_OPTIONS_PRESET_HIGH_QUALITY.web\n    );\n\n    return { uri: null, status: await this.getAudioRecordingStatus() };\n  },\n  async startAudioRecording() {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'paused') {\n      mediaRecorder.resume();\n    } else {\n      mediaRecorder.start();\n    }\n\n    return this.getAudioRecordingStatus();\n  },\n  async pauseAudioRecording() {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    // Set status to paused\n    mediaRecorder.pause();\n\n    return this.getAudioRecordingStatus();\n  },\n  async stopAudioRecording() {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'inactive') {\n      return { uri: null, status: this.getAudioRecordingStatus() };\n    }\n\n    const dataPromise = new Promise(\n      resolve => (mediaRecorder.ondataavailable = e => resolve(e.data))\n    );\n\n    await mediaRecorder.stop();\n\n    const data = await dataPromise;\n    const url = URL.createObjectURL(data);\n\n    return { uri: url, status: await this.getAudioRecordingStatus() };\n  },\n  async unloadAudioRecorder() {\n    mediaRecorder = null;\n    return this.getAudioRecordingStatus();\n  },\n};\n"]}